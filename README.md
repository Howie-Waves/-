# 软件设计模式-概念理解

具体练习案例可以访问我的GitHub仓库，链接如下
https://github.com/Howie-Waves/common_Design_Patterns

<img src="C:\Users\Howie Waves\AppData\Roaming\Typora\typora-user-images\image-20240416121230588.png" alt="image-20240416121230588" style="zoom:50%;" />



[TOC]

## Chapter1 概论

#### 一、 计算机软件

计算机软件是指计算机系统中的==**程序及其文档**==

- 程序：计算任务的处理对象以及处理规则的描述
- 文档：为了便于了解程序所需的阐述性资料

#### 二、软件工程

Software = programs + documents + data + ==**knowledge**==

#### 三、 软件设计

软件需求分析解决“做什么”的问题，软件设计过程则解决**“怎么做”**的问题 

软件设计是把软件需求变换成软件表示的过程，软件设计是将用户需求准确地转化成为最终的软件产品的唯一途径，在<u>需求到实现</u>之间起到了桥梁作用

##### （1）面向对象程序设计(OOP)

- 可复用性
  - 找到相关对象
  - 按照合适的粒度将其分类
  - 定义类的接口和继承层次
  - 建立对象之间的基本关系
- 好的面向对象设计
  - 对手头的问题具有***针对性***
  - 对未来可能发生的问题或产生的需求有***通用性***
  - 避免重复设计或尽可能***少做重复***设计

#### 四、设计模式

==**“模式”**==是指遵从某种规则或规律反复出现的思维方式或表现。

模式的<u>普通定义</u>: 在**一个环境**下针对**某个问题**的**一种解决方案**

==**软件设计模式**==：一个设计模式事实上是系统地命名、解释和评价某一个重要的可重现的面向对象的设计方案。

##### （1）基本要素

> 1. 模式名
> 2. 问题
> 3. 解决方案
> 4. 效果

##### （2）分类

1. 创建型模式 (Creational pattern)  

   > 与对象的创建有关
   >
   > 创建型类模式将对象的部分创建工作**延迟**到子类。创建型对象模式则将它延迟到另一个对象中。

   - 工厂模式
   - 单件模式

2. 结构型模式 (Structural pattern) 

   > 处理类和对象的组合，将一组对象组合成一个大的结构，例如复杂的用户界面
   >
   > 结构型类模式使用继承机制组合类，结构型对象模式则描述对象的组装方式

   - 适配器模式
   - 组合模式
   - 装饰模式
   - 外观模式

3. 行为型模式 (Behavioral pattern) 

   > 描述类或对象的交互和职责分配，定义对象间的通信和复杂程序中的流控
   >
   > 行为型类模式使用继承机制描述算法和控制流，行为型对象模式则描述一组对象如何协作完成单个对象无法完成的任务。

   - 策略模式
   - 命令模式
   - 模板方法模式
   - 观察者模式
   - 迭代器模式
   - 状态模式

<img src="C:\Users\Howie Waves\AppData\Roaming\Typora\typora-user-images\image-20240415114111605.png" alt="image-20240415114111605" style="zoom:50%;" />



## Chapter2 策略模式

#### 一、模式概念

策略模式定义了==**算法族**==，分别封装起来，让它们之间可以互相替换，让算法的变化独立于使用算法的客户。



#### 二、设计原则

- **开闭原则（Open/Closed Principle, OCP）**：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭
  - 教材原话：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
- **依赖倒置原则（Dependency Inversion Principle，DIP）**：高层模块不应该依赖于底层模块，两者都应该依赖于抽象。抽象不应该依赖于具体实现细节，具体实现细节应该依赖于抽象。
  - 教材原话：针对接口（超类型）编程，而不是针对实现编程
- **多用组合，少用继承**



#### 三、理解

##### （1）使用场景

- 有很多相关的类，具有不同的行为（鸭子——飞、叫、游泳）

- 算法具有很多变种

- 算法使用的数据无需客户知晓

- 对很多行为有很多`if-else `语句

##### （2）优点

- 提供一种**替代继承**的方法

- **去掉 `if-else`**语句

- 为同种行为提供不同的实现（不同鸭子叫法不同）

##### （3）缺点

- 客户应该知道所有策略

- 策略和环境之间的通信开销

- 太多策略的类

##### （4）与其他模式比较



## Chapter3 观察者模式

#### 一、模式概念

观察者模式定义了对象之间的==**一对多**==依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新



#### 二、设计原则

- **单一职责原则（Single Responsibility Principle，SRP）**：每个类应该只有一个改变的理由。这个原则强调将功能分解成小的、管理性好的部分，每个部分解决一个单一的功能或责任。
  - 教材原话：功能独立：开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立。 
    - 内聚（cohesion）是一个模块**内部**各个元素彼此结合的紧密程度的度量
    - 耦合（coupling）是模块**之间**的相对独立性（互相连接的紧密程度）的度量
  - 功能独立性比较强的模块应是**==高内聚低耦合==**的模块



#### 三、理解

##### （1）要点分析

- 主题，或者说被观察者，用一个统一的接口通知观察者

- 观察者是松耦合的，在于被观察者并不知道它们的细节

- 可从被观察者处“推”或“拉”数据

- 不要依赖于观察者被通知的顺序

##### （2）优点

- 将实现层和数据逻辑层分离开

- 建立一个主题和观察者之间的**抽象的耦合**

- 支持**广播**通信



## Chapter4 装饰模式

#### 一、模式概念

装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。



#### 二、设计原则

- **开放封闭原则 (Open/Closed Principle, OCP)**
  - 教材原话：类应该对扩展开放，对修改关闭



#### 三、理解

##### （0）要点分析

- 装饰者和被装饰对象有**相同的超类型**。
- 可以用一个或多个装饰者包装一个对象

##### （1）使用场景

- 需要为一个对象**动态添加责任**，并且不影响其他对象。

- 处理**可撤销**的**责任**。

- 当生成子类不可行的时候，比如需要**大量子类**来支持各种**排列组合**。

##### （2）优点

- 比静态继承有更多灵活性

- 在高层类中防止过多特征

##### （3）缺点

- 装饰者会引入**大量的小类**，导致复用变得复杂



## Chapter5 工厂模式

#### 一、模式概念

工厂：工厂用以处理对象创建的细节，其**==封装了变化==**的部分

**工厂方法模式**定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

**抽象工厂模式**提供一个接口，用于创建相关或依赖对象的**家族**，而不需要明确指定具体类。

- **简单工厂模式（Simple Factory Pattern）**：简单工厂模式通过**一个单独的工厂类**来创建所有的产品对象。客户端只需要通过工厂类的静态方法或者实例方法来获取所需的产品对象，而不需要直接调用产品类的构造函数。

- **工厂方法模式（Factory Method Pattern）**：工厂方法模式**将对象的创建延迟到子类**来实现。具体工厂类继承自一个工厂接口或者抽象类，并实现工厂接口中的工厂方法，该方法返回具体产品的实例。

- **抽象工厂模式（Abstract Factory Pattern）**：抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。它涉及到多个产品接口、多个具体产品类和多个具体工厂类，每个具体工厂类负责创建一组相关的产品。



#### 二、设计原则

- **依赖倒置原则**：不能让高层组件依赖低层组件，而两者都要依赖于“抽象” 
  - 教材原话：要依赖抽象，不要依赖具体类



#### 三、理解

##### （1）要点分析

- **工厂方法依赖于==继承==**：对象创建委托给子类，子类实现工厂方法创建对象
- **抽象工厂依赖于==对象组合==**：对象创建由工厂接口中的方法进行实现。
- 所有的工厂模式都促进松耦合，具体是通过减少应用对于具体类型的依赖实现。
-  工厂是一个面向抽象编程而不是面向具体实现编程的有力工具

##### （2）区别

- 简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）

- 工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）  

- 抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）  



## Chapter6 单件模式

#### 一、模式概念

单件模式确保==**一个类只有一个实例**==，并提供一个全局访问点来访问该实例。

应用场景：线程池、缓存、注册表、日志……

#### 二、设计原则



#### 三、理解

##### （1）要点分析

- 单件模式确保你在应用中对一个类最多只有一个实例

- JAVA对单件模式的实现利用了一个私有的构造器，一个静态方法和一个静态变量

- 基于你对性能和资源限制的要求，可以选择一个合适的方法来解决多线程下的单件模式问题。

##### （2）处理多线程

- 把getInstance( )变成同步方法

```java
public class Singleton{
	private static Singleton uniqueInstance;
    private Singleton() {}
    public static synchronized Singleton getInstance(){
        if(uniqueInstance == null)
            uniqueInstance = new Singleton();
        return uniqueInstance;
    }
}
```



- 急切实例化

```java
public class Singleton{
	private static Singleton uniqueInstance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance(){
        return uniqueInstance;
    }
}
```



- 双重检查加锁

```java
public class Singleton{
	private volatile static Singleton uniqueInstance;
    private Singleton() {}
    public static Singleton getInstance(){
        if(uniqueInstance == null){
            synchronized(Singleton.class){
                if(uniqueInstance == null)
                    uniqueInstance = new Singleton();
            }
        }
        return uniqueInstance;
    }
}
```



## Chapter7 命令模式

#### 一、模式概念

命令模式将”请求“封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。



#### 二、设计原则



#### 三、理解

##### （1）要点分析

- 一个**命令对象**通过在特定**接收者**上绑定一组动作来封装一个请求
- 一个**命令对象**是这个解耦的中心，它封装了一个接收者和一个动作
- 命令对象将动作和接收者包进对象中，**只暴露**出一个execute( )方法
- Command接口中除了execute( )方法，还可以有undo( )方法

##### （2）优点

- 命令模式将发起请求的对象和真正执行的对象**解耦**
- 方便增加新命令
- 方便撤销和重做

##### （3）缺点

- 太多具体的命令类



## Chapter8 适配器模式与外观模式

#### 一、模式概念

**适配器模式**将一个类的接口，转化成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

**外观模式**提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用

#### 二、设计原则

- **最少知识原则 (Principle of Least Knowledge)**：一个对象应当尽可能少地了解其他对象（只与直接的朋友通信）。这有助于减少系统中各部分之间的耦合。
  - 教材原话：只和你的密友谈话

#### 三、理解

##### （1）适配器模式要点分析

- 适配器模式由适配器（Adapter）、目标接口（Target）和被适配者（Adaptee）组成。
- 适配器类实现目标接口，并持有一个被适配者的实例，通过调用被适配者的方法来实现目标接口的方法。
- 适配器将客户从实现的接口**解耦**（如果我们想要改变接口，适配器可以将改变的部分封装起来，客户就不必为了应对不同的接口而每次跟着修改）

##### （2）外观模式要点分析

- **简化复杂系统：** 外观模式通过提供一个简单的接口，封装了一个复杂系统的一组接口，使得客户端无需了解系统的内部复杂性，只需与外观对象进行交互即可。
- **提供统一接口：** 外观模式为客户端提供了一个统一的接口，将系统的子系统封装起来，使得客户端无需直接与多个子系统的接口进行交互，降低了客户端与系统之间的耦合度。
- **隐藏实现细节：** 外观模式隐藏了系统的实现细节，使得系统内部的变化对客户端来说是透明的，客户端只需关注外观提供的接口即可，不需要关心系统内部的实现细节。

##### （3）适配器模式 v.s. 外观模式

- 外观模式不只是简化接口，还将客户和子系统组件**解耦**。 

- 外观模式和适配器模式都可以将很多类包装起来，但外观的意图是**==简化==**，而适配器将接口==**转换**==成不同的接口。 



## Chapter9 模板方法模式

#### 一、模式概念

模板方法模式在一个方法中定义算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结果的情况下，重新定义算法中的某些步骤。

#### 二、设计原则

- **好莱坞原则**：不要调用我们（应用程序）的代码，让我们来调用你（框架或库）
  - 教材原话：有了这个原则，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。

#### 三、理解

##### （1）要点分析

- 一个“模板方法”定义了一个算法的步骤, 将某些步骤的实现延迟到子类中，这是代码复用的一个重要技术。
- ==**钩子方法（hook）**==在抽象类中什么也不做，或者做默认的行为。但在子类中可能被**覆盖**。
- 为了防止子类改变模板方法，将模板方法声明成`final`

##### （3）模板方法 v.s. 策略模式 v.s. 工厂模式

- 模板方法：子类决定如何实现算法中的步骤

- 策略模式：封装可互换的行为，然后使用委托来决定要使用哪一个行为

- 工厂方法：由子类决定实例化哪个具体类

```c
//策略模式和模板方法都封装算法，一个通过对象组合，一个通过继承。
//工厂方法是模板方法模式的一种特例。
```



## Chapter 10 迭代器模式与组合模式

#### 一、模式概念

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

组合模式允许你将对象组合成树形结构来表现”整体 / 部分“层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

#### 二、设计原则

- **单一职责原则 (Single Responsibility Principle, SRP)**：每个类应该只有一个改变的理由。这个原则强调将功能分解成小的、管理性好的部分，每个部分解决一个单一的功能或责任。

#### 三、理解

##### （1）迭代器模式

- **访问聚合对象的元素：** 提供一种顺序访问一个聚合对象中各个元素的方法，而**不暴露其内部**表示。
- **分离遍历算法和集合实现：** 迭代器模式将遍历算法与集合实现分离开来，使得可以独立修改它们而不会相互影响

##### （2）组合模式

- **表示==部分-整体==层次结构：** 组合模式用于创建部分-整体层次结构，其中单个对象和组合对象都可以被**一致地对待**。
- **简化客户端代码：** 组合模式使得客户端代码更加简洁，因为客户端不需要对单个对象和组合对象分别进行处理，而是**统一使用相同的接口**进行操作。



## Chapter 11 状态模式

#### 一、模式概念

状态模式允许对象在内部状态改变时改变他的行为，对象看起来好像修改了他的类

#### 二、设计原则

用到了多种设计原则

#### 三、理解

##### （1）要点分析

- 这个模式**将状态封装成为独立的类**，并将动作委托到代表当前状态的对象，我们知道行为会随着内部状态而改变。

- 从客户的角度来看，如果说你使用的对象能够完全改变它的行为，那么你会觉得这个对象实际上是从别的类实例化而来的。实际上，我们使用**组合**通过简单的引用不同类的对象呈现出这种类的改变的假象。

##### （2）状态模式 v.s. 策略模式

- 状态模式将一群行为封装在状态对象中，行为对于客户来说是透明的。正常情况下，客户不知道状态对象的存在。
- 策略模式中，客户通常委托所要组合的对象改变行为。由客户决定做改变。



## Chapter 12 复合模式

#### 一、模式概念

同时使用多种设计模式

#### 二、设计原则

设计原则汇总↓

#### 三、理解

MVC架构……



## End 设计原则汇总

1. **单一职责原则 (Single Responsibility Principle, SRP)**
   每个类应该只有一个改变的理由。这个原则强调将功能分解成小的、管理性好的部分，每个部分解决一个单一的功能或责任。
2. **开放封闭原则 (Open/Closed Principle, OCP)**
   软件实体应当对扩展开放，对修改封闭。也就是说，软件的行为应该可以扩展，而无需修改已有的代码。
3. **里氏替换原则 (Liskov Substitution Principle, LSP)**
   子类对象应该能够替换它们的基类对象被使用，而不破坏程序的正确性。这个原则强调继承时基类和子类之间的行为兼容。
4. **接口隔离原则 (Interface Segregation Principle, ISP)**
   不应该强迫客户依赖于它们不使用的接口。一个类对另一个类的依赖应该建立在最小的接口上。
5. **依赖倒置原则 (Dependency Inversion Principle, DIP)**
   高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。这个原则是为了减少类间的依赖性。
6. **组合优于继承原则 (Composition over Inheritance)**
   使用组合而非继承来实现软件的复用。通常组合可以提供更大的灵活性，通过简单地组合不同的对象，可以定义新的功能。
7. **最少知识原则 (Principle of Least Knowledge)**
   一个对象应当尽可能少地了解其他对象（只与直接的朋友通信）。这有助于减少系统中各部分之间的耦合。
